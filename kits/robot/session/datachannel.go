package session

import (
	"sync"

	kitlog "github.com/doublemo/baa/cores/log/level"
	"github.com/pion/webrtc/v3"
)

const defaultDataChannelLabel = "baa-datachannel"

type (
	// ICEServer defines parameters for ice servers
	ICEServer struct {
		URLs           []string `alias:"urls"`
		Username       string   `alias:"username"`
		Credential     string   `alias:"credential"`
		CredentialType int      `alias:"credentialType"`
	}

	// DataChannelConfig 通道配置
	DataChannelConfig struct {
		// ICEServers defines a slice describing servers available to be used by
		// ICE, such as STUN and TURN servers.
		ICEServers []ICEServer `alias:"iceServers"`

		// ICETransportPolicy indicates which candidates the ICEAgent is allowed
		// to use.
		ICETransportPolicy int `alias:"iceTransportPolicy"`

		// BundlePolicy indicates which media-bundling policy to use when gathering
		// ICE candidates.
		BundlePolicy int `alias:"bundlePolicy"`

		// RTCPMuxPolicy indicates which rtcp-mux policy to use when gathering ICE
		// candidates.
		RTCPMuxPolicy int `alias:"rtcpMuxPolicy"`

		// PeerIdentity sets the target peer identity for the PeerConnection.
		// The PeerConnection will not establish a connection to a remote peer
		// unless it can be successfully authenticated with the provided name.
		PeerIdentity string `alias:"peerIdentity"`

		// Certificates describes a set of certificates that the PeerConnection
		// uses to authenticate. Valid values for this parameter are created
		// through calls to the GenerateCertificate function. Although any given
		// DTLS connection will use only one certificate, this attribute allows the
		// caller to provide multiple certificates that support different
		// algorithms. The final certificate will be selected based on the DTLS
		// handshake, which establishes which certificates are allowed. The
		// PeerConnection implementation selects which of the certificates is
		// used for a given connection; how certificates are selected is outside
		// the scope of this specification. If this value is absent, then a default
		// set of certificates is generated for each PeerConnection instance.
		Certificates []string `alias:"certificates"`

		// ICECandidatePoolSize describes the size of the prefetched ICE pool.
		ICECandidatePoolSize uint8 `alias:"iceCandidatePoolSize"`

		// SDPSemantics controls the type of SDP offers accepted by and
		// SDP answers generated by the PeerConnection.
		SDPSemantics string `alias:"sdpSemantics"`
	}

	// DataChannel 数据通道
	DataChannel struct {
		pc         *webrtc.PeerConnection
		dcs        map[string]*webrtc.DataChannel
		candidates []webrtc.ICECandidateInit
		mutex      sync.RWMutex
	}
)

// OnICEConnectionStateChange call
func (dc *DataChannel) OnICEConnectionStateChange(f func(webrtc.ICEConnectionState)) {
	dc.pc.OnICEConnectionStateChange(f)
}

func (dc *DataChannel) OnICECandidate(f func(*webrtc.ICECandidate)) {
	dc.pc.OnICECandidate(f)
}

// AddDataChannel add
func (dc *DataChannel) AddDataChannel(label string) (*webrtc.DataChannel, error) {
	dc.mutex.Lock()
	m, ok := dc.dcs[label]
	dc.mutex.Unlock()
	if ok {
		return m, nil
	}
	return dc.CreateDataChannel(label, &webrtc.DataChannelInit{})
}

func (dc *DataChannel) CreateDataChannel(label string, option *webrtc.DataChannelInit) (*webrtc.DataChannel, error) {
	dc.mutex.Lock()
	defer dc.mutex.Unlock()
	mdc, err := dc.pc.CreateDataChannel(label, option)
	if err != nil {
		return nil, err
	}

	dc.dcs[label] = mdc
	return mdc, nil
}

func (dc *DataChannel) DataChannel(labels ...string) (*webrtc.DataChannel, bool) {
	var label = defaultDataChannelLabel
	if len(labels) > 0 {
		label = labels[0]
	}

	dc.mutex.RLock()
	m, ok := dc.dcs[label]
	dc.mutex.RUnlock()
	return m, ok
}

// RemoveDataChannel remove
func (dc *DataChannel) RemoveDataChannel(label string) {
	dc.mutex.Lock()
	delete(dc.dcs, label)
	dc.mutex.Unlock()
}

func (dc *DataChannel) Offer(restartIce bool) (webrtc.SessionDescription, error) {
	dc.mutex.Lock()
	defer dc.mutex.Unlock()

	offer, err := dc.pc.CreateOffer(&webrtc.OfferOptions{ICERestart: restartIce})
	if err != nil {
		return webrtc.SessionDescription{}, err
	}

	err = dc.pc.SetLocalDescription(offer)
	if err != nil {
		return webrtc.SessionDescription{}, err
	}
	return offer, nil
}

// AddICECandidate add/set
func (dc *DataChannel) AddICECandidate(candidate webrtc.ICECandidateInit) error {
	dc.mutex.Lock()
	defer dc.mutex.Unlock()

	if dc.pc.RemoteDescription() != nil {
		return dc.pc.AddICECandidate(candidate)
	}

	if dc.candidates == nil {
		dc.candidates = []webrtc.ICECandidateInit{candidate}
	} else {
		dc.candidates = append(dc.candidates, candidate)
	}
	return nil
}

func (dc *DataChannel) RemoteDescription() *webrtc.SessionDescription {
	dc.mutex.Lock()
	defer dc.mutex.Unlock()

	return dc.pc.RemoteDescription()
}

func (dc *DataChannel) SetRemoteDescription(desc webrtc.SessionDescription) error {
	dc.mutex.Lock()
	defer dc.mutex.Unlock()

	if err := dc.pc.SetRemoteDescription(desc); err != nil {
		return err
	}

	if dc.candidates != nil {
		for _, candidate := range dc.candidates {
			if err := dc.pc.AddICECandidate(candidate); err != nil {
				kitlog.Error(Logger()).Log("Add  ice candidate to peer err:", err)
			}
		}
	}
	dc.candidates = nil
	return nil
}

// Close 关闭
func (dc *DataChannel) Close() error {
	return dc.pc.Close()
}

// Send 发送信息到数据通道
func (dc *DataChannel) Send(msg []byte) error {
	dc.mutex.RLock()
	for _, d := range dc.dcs {
		dc.mutex.RUnlock()
		if err := d.Send(msg); err != nil {
			return err
		}
		dc.mutex.RLock()
	}
	dc.mutex.RUnlock()
	return nil
}

// MakeWebrtcConfiguration 创建webrtc.Configuration
func MakeWebrtcConfiguration(c DataChannelConfig) (webrtc.Configuration, error) {
	var config webrtc.Configuration
	if len(c.ICEServers) > 0 {
		config.ICEServers = make([]webrtc.ICEServer, len(c.ICEServers))
		for i, iceserver := range c.ICEServers {
			config.ICEServers[i] = webrtc.ICEServer{
				URLs:           iceserver.URLs,
				Username:       iceserver.Username,
				Credential:     iceserver.Credential,
				CredentialType: webrtc.ICECredentialType(iceserver.CredentialType),
			}
		}
	} else {
		config = webrtc.Configuration{
			ICEServers: []webrtc.ICEServer{
				{
					URLs: []string{"stun:stun.l.google.com:19302"},
				},
			},
		}
	}

	config.ICETransportPolicy = webrtc.ICETransportPolicy(c.ICETransportPolicy)
	config.BundlePolicy = webrtc.BundlePolicy(c.BundlePolicy)
	config.RTCPMuxPolicy = webrtc.RTCPMuxPolicy(c.RTCPMuxPolicy)
	config.PeerIdentity = c.PeerIdentity
	config.ICECandidatePoolSize = c.ICECandidatePoolSize
	sdpSemantics := webrtc.SDPSemanticsUnifiedPlan
	switch c.SDPSemantics {
	case "unified-plan-with-fallback":
		sdpSemantics = webrtc.SDPSemanticsUnifiedPlanWithFallback
	case "plan-b":
		sdpSemantics = webrtc.SDPSemanticsPlanB
	}

	config.SDPSemantics = sdpSemantics
	if len(c.Certificates) > 0 {
		config.Certificates = make([]webrtc.Certificate, 0)
		for _, certificate := range c.Certificates {
			cert, err := webrtc.CertificateFromPEM(certificate)
			if err != nil {
				return config, err
			}

			config.Certificates = append(config.Certificates, *cert)
		}
	}
	return config, nil
}
